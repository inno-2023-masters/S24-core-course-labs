#Persistense memory

```
(base) yanapavlova@MacBook-Air-Ana k8s % kubectl get po,sts,svc,pvc                
NAME                   READY   STATUS    RESTARTS   AGE
pod/python-web-app-0   1/1     Running   0          38s
pod/python-web-app-1   1/1     Running   0          38s

NAME                              READY   AGE
statefulset.apps/python-web-app   2/2     38s

NAME                     TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
service/kubernetes       ClusterIP   10.96.0.1       <none>        443/TCP   6d19h
service/python-web-app   ClusterIP   10.109.105.94   <none>        80/TCP    38s

NAME                                          STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
persistentvolumeclaim/data-python-web-app-0   Bound    pvc-ef53c9d0-a618-47c3-ba8b-f012d2bb5348   1Gi        RWO            standard       13m
persistentvolumeclaim/data-python-web-app-1   Bound    pvc-742a6b20-7d67-46ea-a082-1dc1a793fb14   1Gi        RWO            standard       38s
(base) yanapavlova@MacBook-Air-Ana k8s % kubectl exec pod/python-web-app-0 -- cat /app/data/visits.txt
18   
(base) yanapavlova@MacBook-Air-Ana k8s % kubectl exec pod/python-web-app-1 -- cat /app/data/visits.txt
14                                                                                                               
```

The first pod attracted more visits initially than the second one, likely because minikube service favored directing requests to the first pod while the second pod mostly handled healthcheck requests. If load balancing had been implemented, the visit counts might have been more evenly spread out.

#Lack of Ordering Guarantees

As for ordering guarantees, they're not needed for my application since each pod operates independently. Therefore, we can start multiple pods simultaneously without worrying about sequential ordering.